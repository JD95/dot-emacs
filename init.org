#+TITLE: Emacs configuration file
#+AUTHOR: Jeff Dwyer 

#+STARTUP: indent
#+BABEL: :cache yes
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \usepackage{inconsolata}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+PROPERTY: header-args :tangle yes

* About

This is an Emacs configuration file written in [[http://orgmode.org][Org mode]] based on the original
config by [[https://github.com/larstvei/dot-emacs][larstvei]]. I find organizing the various configurations in an org file
to be easier to maintain than keeping separate files. I'm hoping to
meticulously document my emacs configuration to help both myself and others
that want to use this as a starting point for their own setup. Note that I just
recently adding my settings *on top* of larstvei's so there may still be some
choices that seem contradictory or odd.

If you really do want to try this config out, this is how I'd go about it:

Clone the repo.
#+BEGIN_SRC sh :tangle no
git clone https://gitlab.com/JD95/dot-emacs
#+END_SRC

Backup your old =~/.emacs.d= (if necessary).
#+BEGIN_SRC sh :tangle no
mv ~/.emacs.d ~/.emacs.d-bak
#+END_SRC

Backup your old =~/.emacs=-file (if necessary).
#+BEGIN_SRC sh :tangle no
mv ~/.emacs ~/.emacs-bak
#+END_SRC

And finally
#+BEGIN_SRC sh :tangle no
mv dot-emacs ~/.emacs.d
#+END_SRC

On first run it should install a bunch of packages (this might take a
while), and you might have to restart your Emacs the first time. If you
experience bugs, please let me know!

The init.el file essentially exists to replace itself with the contents
of init.org on the initial load. Subsequent updates to the file can be 
achieved using =update-init-el= which is defined later.

* Configurations

** Packages

Managing extensions for Emacs is simplified using =package= which is
built in to Emacs 24 and newer. To load downloaded packages we need to
initialize =package=. =cl= is a library that contains many functions from
Common Lisp, and comes in handy quite often, so we want to make sure it's
loaded, along with =package=, which is obviously needed.

#+BEGIN_SRC emacs-lisp
(require 'cl)
(require 'package)
(package-initialize)
#+END_SRC

Packages can be fetched from different mirrors, [[http://melpa.milkbox.net/#/][melpa]] is the largest
archive and is well maintained.

#+BEGIN_SRC emacs-lisp
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
(add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/"))
(add-to-list 'package-archives '("elpa" . "http://tromey.com/elpa/"))
(add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/"))
(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
#+END_SRC

The configuration assumes that the packages listed below are
installed. To ensure we install missing packages if they are missing.

#+BEGIN_SRC emacs-lisp

(setq package-selected-packages
 '(
   ;; System
   auto-compile         ; automatically compile Emacs Lisp libraries
   idle-require         ; load elisp libraries while Emacs is idle
   try                  ; Try out Emacs packages
   which-key            ; Display available keybindings in popup
   exec-path-from-shell
   
   ;; Editing
   company              ; Modular text completion framework
   drag-stuff           ; Drag stuff around in Emacs
   pdf-tools            ; Emacs support library for PDF files
   paredit              ; minor mode for editing parentheses
   multiple-cursors     ; Multiple cursors for Emacs
   focus                ; Dim color of text in surrounding sections
   diminish             ; Diminished modes from modeline
   expand-region        ; Increase selected region by semantic units
   
   ;; Themes
   gotham-theme

   ;; Package Management
   use-package
   define-word          ; display the definition of word at point
   
   ;; Navigation
   avy
   smooth-scrolling
   evil
   evil-magit
   evil-org
   evil-tutor
   helm                 ; Incremental and narrowing framework
   helm-ag              ; the silver searcher with helm interface
   helm-company         ; Helm interface for company-mode
   helm-projectile      ; Helm integration for Projectile
   helm-swoop           ; Efficiently hopping squeezed lines
  
   ;; Project Management
   projectile           ; Manage and navigate projects in Emacs easily
   git-gutter-fringe    ; Fringe version of git-gutter.el
   magit                ; control Git from Emacs
   flycheck
   
   ;; Writing 
   org                  ; Outline-based notes management and organizer
   org-ref              ; citations bibliographies in org-mode
   ox-reveal
   ox-twbs
   
   ;; Windows
   powershell
   
   ;; Haskell
   haskell-mode         ; A Haskell editing mode
   intero
   hlint-refactor
   shm
   
   ;; Idris
   idris-mode
   
   ;; Purescript
   purescript-mode
   psc-ide

   ;; Coq
   company-coq

   ;; Elisp
   slime                ; Superior Lisp Interaction Mode for Emacs
   elmacro
   lispy
   evil-lispy
   
   ;; Rust
   rust-mode
   racer
   flycheck-rust
   cargo
   
   ;; Python
   elpy
   py-autopep8
   
   ;; Javascript
   js2-mode             ; Improved JavaScript editing mode
  
   ;; Markdown
   markdown-mode        ; Emacs Major mode for Markdown-formatted files
   ))

(ignore-errors ;; This package is only relevant for Mac OS X.
  (when (memq window-system '(mac ns))
        (push 'exec-path-from-shell packages)
        (push 'reveal-in-osx-finder packages)))

(package-initialize)
(unless package-archive-contents
    (package-refresh-contents))
(package-install-selected-packages)
#+END_SRC

Some packages need to be installed manually, so we add a custom folder to the load path
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/lisp/")
#+END_SRC

** macOS 

Settings for macOS machines. =exec-path-from-shell= is included to solve
path issues. It to includes environment-variables from the shell, making 
using Emacs along with external processes a lot simpler. I also prefer 
using the =Command=-key as the =Meta=-key.

#+BEGIN_SRC emacs-lisp
(when (memq window-system '(mac ns))
  (setq ns-pop-up-frames nil
        mac-option-modifier nil
        mac-command-modifier 'meta
        x-select-enable-clipboard t)
  (exec-path-from-shell-initialize)
  (when (fboundp 'mac-auto-operator-composition-mode)
    (mac-auto-operator-composition-mode 1)))
#+END_SRC

** Linux

Settings specific for linux installs. Like macOS, =exec-path-from-shell= will
be used to resolve environment variables from the shell.

#+BEGIN_SRC emacs-lisp
(when (eq window-system 'gnu/linux)
  (exec-path-from-shell-initialize))
#+END_SRC
** Require

   Some features are not loaded by default to minimize initialization time,
   so they have to be required (or loaded, if you will). =require=-calls
   tends to lead to the largest bottleneck's in a
   configuration. =idle-require= delays the =require=-calls to a time where
   Emacs is in idle. So this is great for stuff you eventually want to load,
   but is not a high priority.

   #+BEGIN_SRC emacs-lisp
   (require 'idle-require)             ; Need in order to use idle-require

   (dolist (feature
            '(auto-compile             ; auto-compile .el files
              ox-latex                 ; the latex-exporter (from org)
              ox-md                    ; Markdown exporter (from org)
              recentf                  ; recently opened files
              tex-mode))               ; TeX, LaTeX, and SliTeX mode commands
     (idle-require feature))

   (setq idle-require-idle-delay 5)
   (idle-require-mode 1)
   #+END_SRC
** Machine Dependent Settings

I pull out any machine specific settings like paths or keys and put them in
a config.json file which is not tracked by version control.

#+BEGIN_SRC emacs-lisp
(require 'json)
(let* ((json-object-type 'hash-table)
       (json-array-type 'list)
       (json-key-type 'string)
       (json (json-read-file "~/.emacs.d/config.json")))
  (setq emacs-config json))
#+END_SRC

** Sane defaults

   These are what /I/ consider to be saner defaults.

   We can set variables to whatever value we'd like using =setq=.

   #+BEGIN_SRC emacs-lisp
   (setq auto-revert-interval 1            ; Refresh buffers fast
         custom-file (make-temp-file "")   ; Discard customization's
         default-input-method "TeX"        ; Use TeX when toggling input method
         echo-keystrokes 0.1               ; Show keystrokes asap
         inhibit-startup-message t         ; No splash screen please
         initial-scratch-message nil       ; Clean scratch buffer
         recentf-max-saved-items 100       ; Show more recent files
         ring-bell-function 'ignore        ; Quiet
         sentence-end-double-space nil)    ; No double space
   ;; Some mac-bindings interfere with Emacs bindings.
   (when (boundp 'mac-pass-command-to-system)
     (setq mac-pass-command-to-system nil))
   #+END_SRC

   Some variables are buffer-local, so changing them using =setq= will only
   change them in a single buffer. Using =setq-default= we change the
   buffer-local variable's default value.

   #+BEGIN_SRC emacs-lisp
   (setq-default indent-tabs-mode nil              ; Use spaces instead of tabs
                 split-width-threshold 160         ; Split verticly by default
                 split-height-threshold nil)       ; Split verticly by default
   #+END_SRC

   The =load-path= specifies where Emacs should look for =.el=-files (or
   Emacs lisp files). I have a directory called =site-lisp= where I keep all
   extensions that have been installed manually (these are mostly my own
   projects).

   #+BEGIN_SRC emacs-lisp
   (let ((default-directory (concat user-emacs-directory "site-lisp/")))
     (when (file-exists-p default-directory)
       (setq load-path
             (append
              (let ((load-path (copy-sequence load-path)))
                (normal-top-level-add-subdirs-to-load-path)) load-path))))
   #+END_SRC

   Answering /yes/ and /no/ to each question from Emacs can be tedious, a
   single /y/ or /n/ will suffice.

   #+BEGIN_SRC emacs-lisp
   (fset 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

   To avoid file system clutter we put all auto saved files in a single
   directory.

   #+BEGIN_SRC emacs-lisp
   (defvar emacs-autosave-directory
     (concat user-emacs-directory "autosaves/")
     "This variable dictates where to put auto saves. It is set to a
     directory called autosaves located wherever your .emacs.d/ is
     located.")

   ;; Sets all files to be backed up and auto saved in a single directory.
   (setq backup-directory-alist
         `((".*" . ,emacs-autosave-directory))
         auto-save-file-name-transforms
         `((".*" ,emacs-autosave-directory t)))
   #+END_SRC

   Set =utf-8= as preferred coding system.

   #+BEGIN_SRC emacs-lisp
   (set-language-environment "UTF-8")
   #+END_SRC

   By default the =narrow-to-region= command is disabled and issues a
   warning, because it might confuse new users. I find it useful sometimes,
   and don't want to be warned.

   #+BEGIN_SRC emacs-lisp
   (put 'narrow-to-region 'disabled nil)
   #+END_SRC

   Automaticly revert =doc-view=-buffers when the file changes on disk.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'doc-view-mode-hook 'auto-revert-mode)
   #+END_SRC

** Modes

There are some modes that are enabled by default that I don't find
particularly useful. We create a list of these modes, and disable all of
these.

#+BEGIN_SRC emacs-lisp
(dolist (mode
         '(tool-bar-mode                ; No toolbars, more room for text
           scroll-bar-mode              ; No scroll bars either
           menu-bar-mode                ; No menubar
           blink-cursor-mode))          ; The blinking cursor gets old
  (funcall mode 0))
#+END_SRC

Let's apply the same technique for enabling modes that are disabled by
default.

#+BEGIN_SRC emacs-lisp
(dolist (mode
         '(abbrev-mode                  ; E.g. sopl -> System.out.println
           column-number-mode           ; Show column number in mode line
           delete-selection-mode        ; Replace selected text
           dirtrack-mode                ; directory tracking in *shell*
           drag-stuff-global-mode       ; Drag stuff around
           global-company-mode          ; Auto-completion everywhere
           global-git-gutter-mode       ; Show changes latest commit
           global-prettify-symbols-mode ; Greek letters should look greek
           projectile-global-mode       ; Manage and navigate projects
           recentf-mode                 ; Recently opened files
           show-paren-mode              ; Highlight matching parentheses
           smooth-scrolling-mode
           which-key-mode))             ; Available keybindings in popup
  (funcall mode 1))

(auto-fill-mode -1)
(remove-hook 'text-mode-hook #'turn-on-auto-fill)

(when (version< emacs-version "24.4")
  (eval-after-load 'auto-compile
    '((auto-compile-on-save-mode 1))))  ; compile .el files on save
#+END_SRC

** Visual

Change the color-theme to =gotham=.

#+BEGIN_SRC emacs-lisp
(load-theme 'gotham t)
#+END_SRC

Use the [[ https://github.com/tonsky/FiraCode][Fira Code]] font if it's installed on the system.

#+BEGIN_SRC emacs-lisp
(cond ((member "Fira Code" (font-family-list))
       (set-face-attribute 'default nil :font "Fira Code")
       (set-frame-font "Fira Code" nil t)))
#+END_SRC

diminish.el]] allows you to hide or abbreviate their presence in the
modeline. I rarely look at the modeline to find out what minor-modes are
enabled, so I disable every global minor-mode, and some for lisp editing.

To ensure that the mode is loaded before diminish it, we should use
~with-eval-after-load~. To avoid typing this multiple times a small macro
is provided.

#+BEGIN_SRC emacs-lisp
(defmacro safe-diminish (file mode &optional new-name)
  `(with-eval-after-load ,file
     (diminish ,mode ,new-name)))

(safe-diminish "eldoc" 'eldoc-mode)
(safe-diminish "flyspell" 'flyspell-mode)
(safe-diminish "helm-mode" 'helm-mode)
(safe-diminish "projectile" 'projectile-mode)
(safe-diminish "paredit" 'paredit-mode "()")
#+END_SRC

git-gutter-fringe]] gives a great visual indication of where you've made
changes since your last commit. There are several packages that performs
this task; the reason I've ended up with =git-gutter-fringe= is that it
reuses the (already present) fringe, saving a tiny bit of screen-estate.

I smuggled some configurations from [[https://github.com/torenord/.emacs.d/][torenord]], providing a cleaner look.

#+BEGIN_SRC emacs-lisp
(require 'git-gutter-fringe)

(dolist (p '((git-gutter:added    . "#0c0")
             (git-gutter:deleted  . "#c00")
             (git-gutter:modified . "#c0c")))
  (set-face-foreground (car p) (cdr p))
  (set-face-background (car p) (cdr p)))
#+END_SRC

New in Emacs 24.4 is the =prettify-symbols-mode=! It's neat.

#+BEGIN_SRC emacs-lisp
(setq-default prettify-symbols-alist '(("lambda" . ?λ)
                                       ("delta" . ?Δ)
                                       ("gamma" . ?Γ)
                                       ("phi" . ?φ)
                                       ("psi" . ?ψ)))
#+END_SRC

** Helm

~helm~ has a wonderful feature, being able to grep files by ~C-s~ anywhere,
which is useful. [[http://beyondgrep.com/][ack]] is a great ~grep~-replacement, and is designed to
search source code, so I want to use that if it's available.

Note that some changes in bindings are located in the key bindings (found
near the end of the configuration).

#+BEGIN_SRC emacs-lisp
(require 'helm)
(require 'helm-config)

(setq helm-split-window-in-side-p t
      helm-M-x-fuzzy-match t
      helm-buffers-fuzzy-matching t
      helm-recentf-fuzzy-match t
      helm-move-to-line-cycle-in-source t
      projectile-completion-system 'helm)

(when (executable-find "ack")
  (setq helm-grep-default-command
        "ack -Hn --no-group --no-color %e %p %f"
        helm-grep-default-recurse-command
        "ack -H --no-group --no-color %e %p %f"))

;;(set-face-attribute 'helm-selection nil :background "cyan")

(helm-mode 1)
(helm-projectile-on)
(helm-adaptive-mode 1)
#+END_SRC

*** Helm dash

    #+BEGIN_SRC emacs-lisp
    (setq helm-dash-browser-func 'eww)
    (add-hook 'emacs-lisp-mode-hook
              (lambda () (setq-local helm-dash-docsets '("Emacs Lisp"))))
    (add-hook 'haskell-mode-hook
              (lambda () (setq-local helm-dash-docsets '("Haskell"))))
    #+END_SRC

** Projectile

Use a custom program for projectile's grep

#+BEGIN_SRC emacs-lisp
(setq find-program (gethash "find" emacs-config))
#+END_SRC 

Enable projectile mode everywhere.

#+BEGIN_SRC emacs-lisp
(projectile-mode)
#+END_SRC
** Evil

These are the configurations for evil mode editing.

#+BEGIN_SRC emacs-lisp
(setq evil-want-abbrev-expand-on-insert-exit nil)
(setq evil-want-integration nil)
(require 'evil)
(evil-mode 1)
(evil-magit-init)
#+END_SRC

** PDF Tools

   [[https://github.com/politza/pdf-tools][PDF Tools]] makes a huge improvement on the built-in [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Document-View.html][doc-view-mode]]; the only
   drawback is the =pdf-tools-install= (which has to be executed before the
   package can be used) takes a couple of /seconds/ to execute. Instead of
   running it at init-time, we'll run it whenever a PDF is opened. Note that
   it's only slow on the first run!

   #+BEGIN_SRC emacs-lisp
   (add-hook 'pdf-tools-enabled-hook 'auto-revert-mode)
   (add-to-list 'auto-mode-alist '("\\.pdf\\'" . pdf-tools-install))
   #+END_SRC

** Completion

   I want a pretty aggressive completion system, hence the no delay settings 
   and short prefix length.

   #+BEGIN_SRC emacs-lisp
   (setq company-idle-delay 0
         company-echo-delay 0
         company-dabbrev-downcase nil
         company-minimum-prefix-length 2
         company-selection-wrap-around t
         company-transformers '(company-sort-by-occurrence
                                company-sort-by-backend-importance))
   #+END_SRC

** Calendar

   Define a function to display week numbers in =calender-mode=. The snippet
   is from [[http://www.emacswiki.org/emacs/CalendarWeekNumbers][EmacsWiki]].

   #+BEGIN_SRC emacs-lisp
   (defun calendar-show-week (arg)
     "Displaying week number in calendar-mode."
     (interactive "P")
     (copy-face font-lock-constant-face 'calendar-iso-week-face)
     (set-face-attribute
      'calendar-iso-week-face nil :height 0.7)
     (setq calendar-intermonth-text
           (and arg
                '(propertize
                  (format
                   "%2d"
                   (car (calendar-iso-from-absolute
                         (calendar-absolute-from-gregorian
                          (list month day year)))))
                  'font-lock-face 'calendar-iso-week-face))))
   #+END_SRC

   Evaluate the =calendar-show-week= function.

   #+BEGIN_SRC emacs-lisp
   (calendar-show-week t)
   #+END_SRC

** Flyspell

   Flyspell offers on-the-fly spell checking. We can enable flyspell for all
   text-modes with this snippet.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'text-mode-hook 'turn-on-flyspell)
   #+END_SRC

   To use flyspell for programming there is =flyspell-prog-mode=, that only
   enables spell checking for comments and strings. We can enable it for all
   programming modes using the =prog-mode-hook=.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'prog-mode-hook 'flyspell-prog-mode)
   #+END_SRC

   When working with several languages, we should be able to cycle through
   the languages we most frequently use. Every buffer should have a separate
   cycle of languages, so that cycling in one buffer does not change the
   state in a different buffer (this problem occurs if you only have one
   global cycle). We can implement this by using a [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Closures.html][closure]].

   #+BEGIN_SRC emacs-lisp
      (defun cycle-languages ()
        "Changes the ispell dictionary to the first element in
      ISPELL-LANGUAGES, and returns an interactive function that cycles
      the languages in ISPELL-LANGUAGES when invoked."
        (lexical-let ((ispell-languages '#1=("american" "norsk" . #1#)))
          (ispell-change-dictionary (car ispell-languages))
          (lambda ()
            (interactive)
            ;; Rotates the languages cycle and changes the ispell dictionary.
            (ispell-change-dictionary
             (car (setq ispell-languages (cdr ispell-languages)))))))
   #+END_SRC

   =flyspell= signals an error if there is no spell-checking tool is
   installed. We can advice =turn-on-flyspell= and =flyspell-prog-mode= to
   only try to enable =flyspell= if a spell-checking tool is available. Also
   we want to enable cycling the languages by typing =C-c l=, so we bind the
   function returned from =cycle-languages=.

   #+BEGIN_SRC emacs-lisp
   (defadvice turn-on-flyspell (before check nil activate)
     "Turns on flyspell only if a spell-checking tool is installed."
     (when (executable-find ispell-program-name)
       (local-set-key (kbd "C-c l") (cycle-languages))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
   (defadvice flyspell-prog-mode (before check nil activate)
     "Turns on flyspell only if a spell-checking tool is installed."
     (when (executable-find ispell-program-name)
       (local-set-key (kbd "C-c l") (cycle-languages))))
   #+END_SRC

** Org

When editing org-files with source-blocks, we want the source blocks to
be themed as they would in their native mode.

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-confirm-babel-evaluate nil
      org-edit-src-content-indentation 0)
#+END_SRC

This is quite an ugly fix for allowing code markup for expressions like
="this string"=, because the quotation marks causes problems.

#+BEGIN_SRC emacs-lisp
;;(require 'org)
(eval-after-load "org"
  '(progn
     (require 'ob-shell)
     (setcar (nthcdr 2 org-emphasis-regexp-components) " \t\n,")
     (custom-set-variables `(org-emphasis-alist ',org-emphasis-alist))))
#+END_SRC

** Interactive functions
   <<sec:defuns>>

This updates the compiled init.el file with any changes made to this file.

#+BEGIN_SRC emacs-lisp
(require 'org)

(defun update-init-el () 
  (interactive)
  ;; Open the configuration
  (find-file (concat user-emacs-directory "init.org"))
  ;; tangle it
  (org-babel-tangle)
  ;; load it
  (load-file (concat user-emacs-directory "init.el"))
  ;; finally byte-compile it
  (byte-compile-file (concat user-emacs-directory "init.el"))
)
#+END_SRC

=just-one-space= removes all whitespace around a point - giving it a
negative argument it removes newlines as well. We wrap a interactive
function around it to be able to bind it to a key. In Emacs 24.4
=cycle-spacing= was introduced, and it works like =just-one-space=, but
when run in succession it cycles between one, zero and the original
number of spaces.

#+BEGIN_SRC emacs-lisp
(defun cycle-spacing-delete-newlines ()
  "Removes whitespace before and after the point."
  (interactive)
  (if (version< emacs-version "24.4")
      (just-one-space -1)
    (cycle-spacing -1)))
#+END_SRC

Often I want to find other occurrences of a word I'm at, or more
specifically the symbol (or tag) I'm at. The
=isearch-forward-symbol-at-point= in Emacs 24.4 works well for this, but
I don't want to be bothered with the =isearch= interface. Rather jump
quickly between occurrences of a symbol, or if non is found, don't do
anything.

#+BEGIN_SRC emacs-lisp
(defun jump-to-symbol-internal (&optional backwardp)
  "Jumps to the next symbol near the point if such a symbol
exists. If BACKWARDP is non-nil it jumps backward."
  (let* ((point (point))
         (bounds (find-tag-default-bounds))
         (beg (car bounds)) (end (cdr bounds))
         (str (isearch-symbol-regexp (find-tag-default)))
         (search (if backwardp 'search-backward-regexp
                   'search-forward-regexp)))
    (goto-char (if backwardp beg end))
    (funcall search str nil t)
    (cond ((<= beg (point) end) (goto-char point))
          (backwardp (forward-char (- point beg)))
          (t  (backward-char (- end point))))))

(defun jump-to-previous-like-this ()
  "Jumps to the previous occurrence of the symbol at point."
  (interactive)
  (jump-to-symbol-internal t))

(defun jump-to-next-like-this ()
  "Jumps to the next occurrence of the symbol at point."
  (interactive)
  (jump-to-symbol-internal))
#+END_SRC

I sometimes regret killing the =*scratch*=-buffer, and have realized I
never want to actually kill it. I just want to get it out of the way, and
clean it up. The function below does just this for the
=*scratch*=-buffer, and works like =kill-this-buffer= for any other
buffer. It removes all buffer content and buries the buffer (this means
making it the least likely candidate for =other-buffer=).

#+BEGIN_SRC emacs-lisp
(defun kill-this-buffer-unless-scratch ()
  "Works like `kill-this-buffer' unless the current buffer is the
,*scratch* buffer. In witch case the buffer content is deleted and
the buffer is buried."
  (interactive)
  (if (not (string= (buffer-name) "*scratch*"))
      (kill-this-buffer)
    (delete-region (point-min) (point-max))
    (switch-to-buffer (other-buffer))
    (bury-buffer "*scratch*")))
#+END_SRC

To duplicate either selected text or a line we define this interactive
function.

#+BEGIN_SRC emacs-lisp
(defun duplicate-thing (comment)
  "Duplicates the current line, or the region if active. If an argument is
given, the duplicated region will be commented out."
  (interactive "P")
  (save-excursion
    (let ((start (if (region-active-p) (region-beginning) (point-at-bol)))
          (end   (if (region-active-p) (region-end) (point-at-eol))))
      (goto-char end)
      (unless (region-active-p)
        (newline))
      (insert (buffer-substring start end))
      (when comment (comment-region start end)))))
#+END_SRC

To tidy up a buffer we define this function borrowed from [[https://github.com/simenheg][simenheg]].

#+BEGIN_SRC emacs-lisp
(defun tidy ()
  "Ident, untabify and unwhitespacify current buffer, or region if active."
  (interactive)
  (let ((beg (if (region-active-p) (region-beginning) (point-min)))
        (end (if (region-active-p) (region-end) (point-max))))
    (indent-region beg end)
    (whitespace-cleanup)
    (untabify beg (if (< end (point-max)) end (point-max)))))
#+END_SRC

Org mode does currently not support synctex (which enables you to jump from
a point in your TeX-file to the corresponding point in the pdf), and it
seems like a tricky problem]].

Calling this function from an org-buffer jumps to the corresponding section
in the exported pdf (given that the pdf-file exists), using pdf-tools.

#+BEGIN_SRC emacs-lisp
(defun org-sync-pdf ()
  (interactive)
  (let ((headline (nth 4 (org-heading-components)))
        (pdf (concat (file-name-base (buffer-name)) ".pdf")))
    (when (file-exists-p pdf)
      (find-file-other-window pdf)
      (pdf-links-action-perform
       (cl-find headline (pdf-info-outline pdf)
                :key (lambda (alist) (cdr (assoc 'title alist)))
                :test 'string-equal)))))
#+END_SRC

This allows a window to shift from a horizontal split into a vertical split

#+BEGIN_SRC emacs-lisp
(defun toggle-window-split ()
  "Change the window split from horizontal to vertical."
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))
#+END_SRC

A utility for inserting the current date. 

#+BEGIN_SRC emacs-lisp
(defun insert-current-date (&optional omit-day-of-week-p)
   "Insert today's date using the current locale.
  With a prefix argument, the date is inserted without the day of
  the week."
   (interactive "P*")
   (insert (calendar-date-string (calendar-current-date) nil
                                 omit-day-of-week-p)))
#+END_SRC

Here are some utilities for setting up a workspace. Generally, they 
are just present window configs generated from a macro.

#+BEGIN_SRC emacs-lisp
(defun general-workspace ()
 "Set up a general split screen workspace."
 (interactive)
 (delete-other-windows nil)
 (split-window-below nil)
 (split-window-right nil)
 (other-window 1)
 (other-window 1)
 (eshell nil))

 (defun single-window-workspace ()
 "Change to a single window workspace."
 (interactive)
 (delete-other-windows nil)
 (neotree-hide))

#+END_SRC

This provides a utility for finding the next non-ascii character. 
This is useful when pasting text from websites or word.

#+BEGIN_SRC emacs-lisp
(defun find-first-non-ascii-char ()
  "Find the first non-ascii character from point onwards."
  (interactive)
  (let (point)
    (save-excursion
      (setq point
            (catch 'non-ascii
              (while (not (eobp))
                (or (eq (char-charset (following-char))
                        'ascii)
                    (throw 'non-ascii (point)))
                (forward-char 1)))))
    (if point
        (goto-char point)
      (message "No non-ascii characters."))))
#+END_SRC   

** file encryption

This fixes a problem using PGP encryption on windows

#+BEGIN_SRC emacs-lisp
(require 'epa-file)
(epa-file-enable)

(defun epg--list-keys-1 (context name mode)
  "A fix for the epa bug.
Argument CONTEXT Not sure.
Argument NAME Not sure.
Argument MODE Not sure."
  (let ((args (append (if (epg-context-home-directory context)
			  (list "--homedir"
				(epg-context-home-directory context)))
		      '("--with-colons" "--no-greeting" "--batch"
			"--with-fingerprint" "--with-fingerprint")
		      (unless (eq (epg-context-protocol context) 'CMS)
			'("--fixed-list-mode"))))
	(list-keys-option (if (memq mode '(t secret))
			      "--list-secret-keys"
			    (if (memq mode '(nil public))
				"--list-keys"
			      "--list-sigs")))
	(coding-system-for-read 'binary)
	keys string field index)
    (if name
	(progn
	  (unless (listp name)
	    (setq name (list name)))
	  (while name
	    (setq args (append args (list list-keys-option (car name)))
		  name (cdr name)))) 
      (setq args (append args (list list-keys-option))))
    (with-temp-buffer
      (apply #'call-process
	     (epg-context-program context)
	     nil (list t nil) nil args)
      (goto-char (point-min))
      (while (re-search-forward "^[a-z][a-z][a-z]:.*" nil t)
	(setq keys (cons (make-vector 15 nil) keys)
	      string (match-string 0)
	      index 0
	      field 0)
	(while (and (< field (length (car keys)))
		    (eq index
			(string-match "\\([^:]+\\)?:" string index)))
	  (setq index (match-end 0))
	  (aset (car keys) field (match-string 1 string))
	  (setq field (1+ field))))
      (nreverse keys))))
#+END_SRC
** Advice

   An advice can be given to a function to make it behave differently. This
   advice makes =eval-last-sexp= (bound to =C-x C-e=) replace the sexp with
   the value.

   #+BEGIN_SRC emacs-lisp
   (defadvice eval-last-sexp (around replace-sexp (arg) activate)
     "Replace sexp when called with a prefix argument."
     (if arg
         (let ((pos (point)))
           ad-do-it
           (goto-char pos)
           (backward-kill-sexp)
           (forward-sexp))
       ad-do-it))
   #+END_SRC

   When interactively changing the theme (using =M-x load-theme=), the
   current custom theme is not disabled. This often gives weird-looking
   results; we can advice =load-theme= to always disable themes currently
   enabled themes.

   #+BEGIN_SRC emacs-lisp
   (defadvice load-theme
       (before disable-before-load (theme &optional no-confirm no-enable) activate)
     (mapc 'disable-theme custom-enabled-themes))
   #+END_SRC

** global-scale-mode

   These functions provide something close to ~text-scale-mode~, but for every
   buffer, including the minibuffer and mode line.

   #+BEGIN_SRC emacs-lisp
   (lexical-let* ((default (face-attribute 'default :height))
                  (size default))

     (defun global-scale-default ()
       (interactive)
       (setq size default)
       (global-scale-internal size))

     (defun global-scale-up ()
       (interactive)
       (global-scale-internal (incf size 20)))

     (defun global-scale-down ()
       (interactive)
       (global-scale-internal (decf size 20)))

     (defun global-scale-internal (arg)
       (set-face-attribute 'default (selected-frame) :height arg)
       (set-temporary-overlay-map
        (let ((map (make-sparse-keymap)))
          (define-key map (kbd "C-=") 'global-scale-up)
          (define-key map (kbd "C-+") 'global-scale-up)
          (define-key map (kbd "C--") 'global-scale-down)
          (define-key map (kbd "C-0") 'global-scale-default) map))))
   #+END_SRC

* Mode specific
** Compilation

   I often run ~latexmk -pdf -pvc~ in a compilation buffer, which recompiles
   the latex-file whenever it is changed. This often results in annoyingly
   large compilation buffers; the following snippet limits the buffer size in
   accordance with ~comint-buffer-maximum-size~, which defaults to 1024 lines.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'compilation-filter-hook 'comint-truncate-buffer)
   #+END_SRC
** Coq
#+BEGIN_SRC emacs-lisp
(ignore-errors
  (load (gethash "coq-proof-site-location" emacs-config)))

(defun coq-setup ()
  (interactive)
  (company-coq-mode)
  (buffer-face-mode))

(add-hook 'coq-mode-hook #'coq-setup)
#+END_SRC
** Haskell

=haskell-doc-mode= is similar to =eldoc=, it displays documentation in
the echo area. Haskell has several indentation modes - I prefer using
=haskell-indent=.

#+BEGIN_SRC emacs-lisp
(setq stack-location (gethash "haskell-stack-location" emacs-config))

(let ((my-stack-path (expand-file-name stack-location)))
  (setenv "PATH" (concat my-stack-path path-separator (getenv "PATH")))
  (add-to-list 'exec-path my-stack-path))

(defun haskell-setup ()
  (drag-stuff-mode)
  (structured-haskell-mode nil)
  (hindent-mode)
  (intero-mode nil)
  )

(setq haskell-stylish-on-save t)
(add-hook 'haskell-mode-hook #'haskell-setup)
(add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)

(require 'shm)
(eval-after-load 'haskell-mode
  '(progn  
       (define-key haskell-mode-map (kbd "M-<up>") 'drag-stuff-up)
	   (define-key haskell-mode-map (kbd "M-<down>") 'drag-stuff-down)
	   (define-key shm-map (kbd "C-c C-s") 'shm/case-split)
	   ))

(with-eval-after-load 'intero
  (flycheck-add-next-checker 'intero '(warning . haskell-hlint)))
#+END_SRC
** Idris
#+BEGIN_SRC emacs-lisp
(add-to-list 'exec-path (gethash "idris-location" emacs-config))
#+END_SRC

** Lisp

   I use =Paredit= when editing lisp code, we enable this for all lisp-modes.

   #+BEGIN_SRC emacs-lisp
   (dolist (mode '(ielm-mode
                   lisp-mode
                   emacs-lisp-mode
                   lisp-interaction-mode
                   scheme-mode))
     ;; add paredit-mode to all mode-hooks
     (add-hook (intern (concat (symbol-name mode) "-hook")) 'paredit-mode))
   #+END_SRC

*** Emacs Lisp

    In =emacs-lisp-mode= we can enable =eldoc-mode= to display information
    about a function or a variable in the echo area.

    #+BEGIN_SRC emacs-lisp
    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
    #+END_SRC
** Markdown

   This makes =.md=-files open in =markdown-mode=.

   #+BEGIN_SRC emacs-lisp
   (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
   #+END_SRC

   I sometimes use a specialized markdown format, where inline math-blocks
   can be achieved by surrounding a LaTeX formula with =$math$= and
   =$/math$=. Writing these out became tedious, so I wrote a small function.

   #+BEGIN_SRC emacs-lisp
   (defun insert-markdown-inline-math-block ()
     "Inserts an empty math-block if no region is active, otherwise wrap a
   math-block around the region."
     (interactive)
     (let* ((beg (region-beginning))
            (end (region-end))
            (body (if (region-active-p) (buffer-substring beg end) "")))
       (when (region-active-p)
         (delete-region beg end))
       (insert (concat "$math$ " body " $/math$"))
       (search-backward " $/math$")))
   #+END_SRC

   Most of my writing in this markup is in Norwegian, so the dictionary is
   set accordingly. The markup is also sensitive to line breaks, so
   =auto-fill-mode= is disabled. Of course we want to bind our lovely
   function to a key!

   #+BEGIN_SRC emacs-lisp
   (add-hook 'markdown-mode-hook
             (lambda ()
               (auto-fill-mode 0)
               (visual-line-mode 1)
               (local-set-key (kbd "C-c b") 'insert-markdown-inline-math-block)) t)
   #+END_SRC
** Org 

Ensure that .org files are opened with org-mode

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
#+END_SRC

Setup evil org mode.

#+BEGIN_SRC emacs-lisp
(require 'evil-org)
(add-hook 'org-mode-hook 'evil-org-mode)
(evil-org-set-key-theme '(navigation insert textobjects additional))
#+END_SRC

Babel Config

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((dot . t)))
#+END_SRC

Use aspell if present, mainly useful on windows.

#+BEGIN_SRC emacs-lisp
(cond
 ((executable-find "aspell")
  (setq ispell-program-name "aspell")
  ;; Please note ispell-extra-args contains ACTUAL parameters passed to aspell
  (setq ispell-extra-args '("--sug-mode=ultra" "--lang=en_US"))
 )
)
#+END_SRC

*** Org Babel

This allows for the execution of literate sh files.

#+BEGIN_SRC emacs-lisp
(defun org-tangle-and-run-sh ()
  (interactive)
  (find-file buffer-file-name)
  (org-babel-tangle)
  (let ((script-file (concat
        (car (split-string buffer-file-name ".org")) ".sh")))
    (shell)
    (insert (concat "chmod +x " script-file))
    (comint-send-input)
    (insert (concat script-file))
    (comint-send-input)
    (delete-file script-file))
)
#+END_SRC

#+RESULTS:
: org-tangle-and-run-sh

*** Org Agenda

Don't delay for scheduled tasks

#+BEGIN_SRC emacs-lisp
(setq org-scheduled-delay-days 0)
#+END_SRC

These functions helps clear out done tasks in an org file

#+BEGIN_SRC emacs-lisp
(defun org-archive-done-tasks ()
  (interactive)
  (org-map-entries
   (lambda ()
     (org-archive-subtree)
     (setq org-map-continue-from (outline-previous-heading)))
   "/DONE" 'file))

(defun org-cut-done-tasks ()
  (interactive)
  (org-map-entries
   (lambda ()
     (org-cut-subtree)
     (setq org-map-continue-from (outline-previous-heading)))
   "/DONE" 'file))
#+END_SRC

Set the default todo keywords

#+BEGIN_SRC emacs-lisp
(setq org-todo-keyword-faces
  '(
	("TODO" . (:foreground "red"))
	("PROGRESSING" . (:foreground "orange"))
        ("HOLD" . (:foreground "yellow"))
	("FAILED" . (:foreground "grey"))
   ))

(setq org-todo-keywords
      '((sequence "TODO" "PROGRESSING" "HOLD" "|" "DONE" "FAILED")))
#+END_SRC

Generates a sequence of todo items based on a sequence of numbers

#+BEGIN_SRC emacs-lisp
(defun org-todo-sequence ()
  "Creates a list of todo items ending with numbers from start to end"
  (interactive)
  (let* ((item (read-string "todo item: "))
	 (start (string-to-number (read-string "start index: ")))
	 (end (string-to-number (read-string "end index: ")))
	 (todo-item (concat "* TODO " item))
	 (line-item (lambda (i) (concat todo-item " " (number-to-string i) "\n")))
	 (items (mapcar line-item (number-sequence start end))))
    (mapc 'insert items)))
#+END_SRC

Sets priority color faces

#+BEGIN_SRC emacs-lisp
(setq org-priority-faces '(
			   (?0 . (:foreground "green"))
                           (?1 . (:foreground "green yellow" :weight 'bold))
                           (?2 . (:foreground "yellow"))
                           (?3 . (:foreground "gold"))
			   (?4 . (:foreground "orange"))
   			   (?5 . (:foreground "chocolate"))
			   (?6 . (:foreground "firebrick"))
			   (?7 . (:foreground "brown"))
			   (?8 . (:foreground "plum"))
			   (?9 . (:foreground "DarkOrchid4"))
			   ))
#+END_SRC

*** Org Export

Sometimes I want to use the same org file to export into different sources,
but not include all of the content. For example, if I'm exporting into a 
presentation, I might not want to export all of the paragraphs. This is done
by adding advice to the various export commands to ignore certain tags.

#+BEGIN_SRC emacs-lisp
(defun org-ascii-set-export-options
    (orig &optional async subtreep visible-only body-only ext-plist)
  (let ((org-export-exclude-tags '("no_ascii_export")))
    (funcall orig async subtreep visible-only body-only ext-plist)))

(advice-add 'org-ascii-export-to-ascii
            :around #'org-ascii-set-export-options)

(advice-add 'org-ascii-export-as-ascii
            :around #'org-ascii-set-export-options)

(defun org-html-set-export-options
    (orig &optional async subtreep visible-only body-only ext-plist)
  (let ((org-export-exclude-tags '("no_html_export")))
    (funcall orig async subtreep visible-only body-only ext-plist)))

(advice-add 'org-html-export-to-html
            :around #'org-html-set-export-options)

(advice-add 'org-html-export-to-html-and-browse
            :around #'org-html-set-export-options)

(defun org-latex-set-export-options
    (orig &optional async subtreep visible-only body-only ext-plist)
  (let ((org-export-exclude-tags '("no_latex_export")))
    (funcall orig async subtreep visible-only body-only ext-plist)))

(advice-add 'org-latex-export-to-pdf
            :around #'org-latex-set-export-options)

(defun org-reveal-set-export-options
    (orig &optional async subtreep visible-only body-only ext-plist)
  (let ((org-export-exclude-tags '("no_reveal_export")))
    (funcall orig async subtreep visible-only body-only ext-plist)))

(advice-add 'org-reveal-export-to-html
            :around #'org-reveal-set-export-options)

(advice-add 'org-reveal-export-to-html-and-browse
            :around #'org-reveal-set-export-options)

(defun org-twbs-set-export-options
    (orig &optional async subtreep visible-only body-only ext-plist)
  (let ((org-export-exclude-tags '("no_twbs_export")))
    (funcall orig async subtreep visible-only body-only ext-plist)))

(advice-add 'org-twbs-export-to-html
            :around #'org-twbs-set-export-options)

(advice-add 'org-twbs-export-to-html-and-browse
            :around #'org-twbs-set-export-options)
#+END_SRC
*** Latex

=.tex=-files should be associated with =latex-mode= instead of
=tex-mode=.

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.tex\\'" . latex-mode))
#+END_SRC

Use ~biblatex~ for bibliography.

#+BEGIN_SRC emacs-lisp
(setq-default bibtex-dialect 'biblatex)
#+END_SRC

When exporting from org-mode to pdf via latex, use pdflatex and bibtex. Uses
an explicit bash command to allow for this to work on windows via the linux
subsystem.

#+BEGIN_SRC emacs-lisp
(setq org-highlight-latex-and-related '(latex script entities))
(setq org-latex-pdf-process
    '("bash -c \"pdflatex -interaction nonstopmode -output-directory %o %f\""
      "bash -c \"bibtex %b\""
      "bash -c \"pdflatex -interaction nonstopmode -output-directory %o %f\""
      "bash -c \"pdflatex -interaction nonstopmode -output-directory %o %f\""))
#+END_SRC
** Purescript
#+BEGIN_SRC emacs-lisp
(require 'psc-ide)

(defun purescript-setup ()
  (psc-ide-mode)
  (company-mode)
  (flycheck-mode)
  (turn-on-purescript-indentation)
  )

(add-hook 'purescript-mode-hook #'purescript-setup)
#+END_SRC
** Python
#+BEGIN_SRC emacs-lisp
(elpy-enable)

(when (require 'flycheck nil t)
  (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
  (add-hook 'elpy-mode-hook 'flycheck-mode))

(setq py-autopep8-options '("--max-line-length=100"))

;; Highlight character at "fill-column" position.
(add-hook 'python-mode-hook
          (lambda () (interactive)
	    (set-variable 'py-indent-offset 4)
            (set-variable 'indent-tabs-mode nil)))
#+END_SRC

** Rust

#+BEGIN_SRC emacs-lisp
(require 'rust-mode)

(defun rust-mode-setup ()
  (cargo-minor-mode nil))

(defun racer-mode-setup ()
  (eldoc-mode))

(add-hook 'rust-mode-hook #'rust-mode-setup)

(define-key rust-mode-map (kbd "TAB") #'company-indent-or-complete-common)
(define-key rust-mode-map (kbd "C-?") #'racer-describe)
(setq company-tooltip-align-annotations t)

(setq rust-format-on-save t)
#+END_SRC

** Shell

   Inspired by [[https://github.com/torenord/.emacs.d][torenord]], I maintain quick access to shell buffers with bindings
   ~M-1~ to ~M-9~. In addition, the ~M-§~ (on an international English
   keyboard) is bound toggle between the last visited shell, and the last
   visited non-shell buffer. The following functions facilitate this, and are
   bound in the [[Key bindings]] section.

   #+BEGIN_SRC emacs-lisp
   (lexical-let ((last-shell ""))
     (defun toggle-shell ()
       (interactive)
       (cond ((string-match-p "^\\*shell<[1-9][0-9]*>\\*$" (buffer-name))
              (goto-non-shell-buffer))
             ((get-buffer last-shell) (switch-to-buffer last-shell))
             (t (shell (setq last-shell "*shell<1>*")))))

     (defun switch-shell (n)
       (let ((buffer-name (format "*shell<%d>*" n)))
         (setq last-shell buffer-name)
         (cond ((get-buffer buffer-name)
                (switch-to-buffer buffer-name))
               (t (shell buffer-name)
                  (rename-buffer buffer-name)))))

     (defun goto-non-shell-buffer ()
       (let* ((r "^\\*shell<[1-9][0-9]*>\\*$")
              (shell-buffer-p (lambda (b) (string-match-p r (buffer-name b))))
              (non-shells (cl-remove-if shell-buffer-p (buffer-list))))
         (when non-shells
           (switch-to-buffer (first non-shells))))))
   #+END_SRC

   Don't query whether or not the ~shell~-buffer should be killed, just kill
   it.

   #+BEGIN_SRC emacs-lisp
   (defadvice shell (after kill-with-no-query nil activate)
     (set-process-query-on-exit-flag (get-buffer-process ad-return-value) nil))
   #+END_SRC

   I'd like the =C-l= to work more like the standard terminal (which works
   like running =clear=), and resolve this by simply removing the
   buffer-content. Mind that this is not how =clear= works, it simply adds a
   bunch of newlines, and puts the prompt at the top of the window, so it
   does not remove anything. In Emacs removing stuff is less of a worry,
   since we can always undo!

   #+BEGIN_SRC emacs-lisp
   (defun clear-comint ()
     "Runs `comint-truncate-buffer' with the
   `comint-buffer-maximum-size' set to zero."
     (interactive)
     (let ((comint-buffer-maximum-size 0))
       (comint-truncate-buffer)))
   #+END_SRC

   The =clear-shell= should only be bound in =comint-mode=, which is a mode
   most shell and REPL's is derived from.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'comint-mode-hook (lambda () (local-set-key (kbd "C-l") 'clear-comint)))
   #+END_SRC
* Templates

This section sets up templates for files like org-mode reveal presentations
or haskell modules.

#+begin_src emacs-lisp
(defun template-get-value (pair)
  (read-string (nth 1 pair)))

(defun template-get-values (pairs)
  (mapcar #'template-get-value pairs)) 

(defmacro template-make-lambda (symbols exp)
  `(lambda ,(mapcar #'car symbols) ,exp))

(defun insert-with-newline (value)
  (interactive)
  (insert value)
  (insert "\n"))

(defmacro template-new-template (symbols exp)
  `(let* ((values (template-get-values (quote ,symbols)))
         (template (apply (template-make-lambda ,symbols ,exp) values)))
     (mapc #'insert-with-newline template)))
#+end_src

** Org
*** latex

#+begin_src emacs-lisp
(defun template-new-org-latex ()
  (interactive)
  (template-new-template
   ((title "title:") (author "author:") (date "date:"))
   `(,(concat "#+title: " title)
     ,(concat "#+author: " author)
     ,(concat "#+date: " date)
     "#+startup: hidestar"
     "#+startup: indent"
     "\n"
     "# latex options"
     "#+options: toc:nil"
     "#+latex_header: \\usepackage[margin=1.5in]{geometry}"
     "#+latex_header: \\usepackage{apacite}"
     "#+latex_header: \\usepackage{setspace}"
     )))
#+end_src

*** reveal

#+BEGIN_SRC emacs-lisp
(defun template-new-org-reveal-presentation ()
  (interactive)
  (template-new-template
   ((title "title:") (author "author:") (date "date:"))
   `("#+STARTUP: indent"
     "#+STARTUP: hidestar"
     ""
     "#+REVEAL_ROOT: http://cdn.jsdelivr.net/reveal.js/3.0.0/"
     "#+REVEAL_THEME: serif"
     "#+OPTIONS: num:nil timestamp:nil html-postamble:nil tags:nil toc:nil"
     ""
     ,(concat "#+TITLE: " title)
     ,(concat "#+AUTHOR: " author)
     ,(concat "#+DATE: " date)
     )))
#+END_SRC

*** comp51
#+begin_src emacs-lisp
(defun template-new-org-comp51-project ()
  (interactive)
  (template-new-template
   ((title "title:"))
   `(,(concat "#+title: " title)
     "#+subtitle: comp 51"
     "#+startup: hidestar"
     "#+startup: indent"
     ""
     "# latex options"
     "#+options: toc:nil num:nil html:postamble:nil date:nil"
     "#+latex_header: \\usepackage[margin=1.5in]{geometry}"
     "#+latex_header: \\usepackage{setspace}"
     ""
     "* objective:"
     ""
     "* description:"
     ""
     "* requirements:"
     )))
#+end_src

*** blogging
#+BEGIN_SRC emacs-lisp
(defun template-new-org-blog-post ()
  (interactive)
  (template-new-template
    ((title "title:"))
    `(,(concat "#+title: " title)
     "#+startup: hidestar"
     "#+startup: indent"
     ""
     "# latex options"
     "#+options: toc:nil num:nil html-postamble:nil date:nil"
     "#+latex_header: \\usepackage[margin=1.5in]{geometry}"
     "#+latex_header: \\usepackage{setspace}"
     ""
  )))
#+END_SRC
** Python

#+BEGIN_SRC emacs-lisp
(defun template-new-python-sript ()
  (interactive)
  (template-new-template
   ()
   '("#!~/usr/bin/env python"
     ""
     "if __name__=='__main__':"
     "    pass"
     )))
#+END_SRC

** Haskell
#+BEGIN_SRC emacs-lisp
(defun template-new-haskell-module ()
  (interactive)
  (template-new-template
   ((module "module:") (f "function:"))
   `(,(concat "module " module " where\n")
     "\n"
     ,(concat f " = undefined\n") 
    )))
#+END_SRC

** Purescript

#+BEGIN_SRC emacs-lisp
(defun template-new-purescript-halogen-component ()
  "Generate a new purescript halogen component."
  (interactive)
  (template-new-template
   ((name "name:"))
   `(,(concat "module Component." name "(State(..),Query(..)," (downcase name) ") where\n")
     ""
     "import CSS"
     "import CSS.Elements as CSS"
     "import CSS.Geometry as CSS"
     "import CSS.Selector as CSS"
     "import CSS.Stylesheet as CSS"
     "import CSS.TextAlign as CSS"
     "import CSS.Size as CSS"
     "import Control.Monad.Aff (Aff)"
     "import DOM.HTmL.Indexed as D"
     "import Data.Maybe (Maybe(..))"
     "import Halogen as H"
     "import Halogen.HTML as HH"
     "import Halogen.HTML.CSS as HC"
     "import Halogen.HTML.Events as HE"
     "import Halogen.HTML.Properties as HP"
     "import Halogen.Themes.Bootstrap3 as HC"
     "import Network.HTTP.Affjax as AX"
     "import Prelude (type (~>), Unit, Void, bind, const, discard, pure, ($))"
     ""
     "import Types as T"
     ""
     "data State = State"
     ""
     "data Query a = Input a"
     ""
     "data ChildQuery a = ChildInput a"
     ""
     "type Slot = Int"
     ""
     "render :: forall eff. State -> H.ParentHTML Query ChildQuery Slot (Aff (T.Effect eff))"
     "render st = HH.div_ []"
     ""
     "initialState :: State"
     "initialState = State"
     ""
     "eval :: forall eff. Query ~> H.ParentDSL State Query ChildQuery Slot Void (Aff (T.Effect eff))"
     "eval = case _ of"
     "  Input next -> pure next"
     ""
     ,(concat (downcase name) " :: forall eff. H.Component HH.HTML Query Unit Void (Aff (T.Effect eff))")
     ,(concat (downcase name) " =")
     "  H.parentComponent"
     "    { initialState: const initialState"
     "    , render"
     "    , eval"
     "    , receiver: const Nothing"
     "    }"))
  )
#+END_SRC

* Key bindings

  Inspired by [[http://stackoverflow.com/questions/683425/globally-override-key-binding-in-emacs][this StackOverflow post]] I keep a =custom-bindings-map= that
  holds all my custom bindings. This map can be activated by toggling a
  simple =minor-mode= that does nothing more than activating the map. This
  inhibits other =major-modes= to override these bindings. I keep this at
  the end of the init-file to make sure that all functions are actually
  defined.

  #+BEGIN_SRC emacs-lisp
  (defvar custom-bindings-map (make-keymap)
    "A keymap for custom bindings.")
  #+END_SRC

** Bindings for [[https://github.com/abo-abo/define-word][define-word]]

  #+BEGIN_SRC emacs-lisp
  (define-key custom-bindings-map (kbd "C-c D") 'define-word-at-point)
  #+END_SRC

** Bindings for [[https://github.com/magnars/expand-region.el][expand-region]]

  #+BEGIN_SRC emacs-lisp
  (define-key custom-bindings-map (kbd "C->")  'er/expand-region)
  (define-key custom-bindings-map (kbd "C-<")  'er/contract-region)
  #+END_SRC

** Bindings for [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]

  #+BEGIN_SRC emacs-lisp
  (define-key custom-bindings-map (kbd "C-c e")  'mc/edit-lines)
  (define-key custom-bindings-map (kbd "C-c a")  'mc/mark-all-like-this)
  (define-key custom-bindings-map (kbd "C-c n")  'mc/mark-next-like-this)
  #+END_SRC

** Bindings for [[http://magit.github.io][Magit]]

#+BEGIN_SRC emacs-lisp
(define-key custom-bindings-map (kbd "C-c m") 'magit-status)
#+END_SRC

** Bindings for [[https://github.com/syohex/emacs-git-gutter-fringe][git-gutter-fringe]]
#+BEGIN_SRC emacs-lisp
(define-key custom-bindings-map (kbd "M-g r") #'git-gutter:update-all-windows)
#+END_SRC
** Bindings for [[http://company-mode.github.io/][company-mode]]

  #+BEGIN_SRC emacs-lisp
  (define-key company-active-map (kbd "C-d") 'company-show-doc-buffer)
  (define-key company-active-map (kbd "C-n") 'company-select-next)
  (define-key company-active-map (kbd "C-p") 'company-select-previous)
  (define-key company-active-map (kbd "<tab>") 'company-complete)

  (define-key company-mode-map (kbd "C-:") 'helm-company)
  (define-key company-active-map (kbd "C-:") 'helm-company)
  #+END_SRC

** Bindings for [[http://emacs-helm.github.io/helm/][Helm]]

  #+BEGIN_SRC emacs-lisp
  (define-key custom-bindings-map (kbd "C-c h")   #'helm-command-prefix)
  (define-key custom-bindings-map (kbd "M-x")     'helm-M-x)
  (define-key custom-bindings-map (kbd "M-y")     #'helm-show-kill-ring)
  (define-key custom-bindings-map (kbd "C-x b")   #'helm-mini)
  (define-key custom-bindings-map (kbd "C-x C-f") #'helm-find-files)
  (define-key custom-bindings-map (kbd "C-c h d") #'helm-dash-at-point)
  (define-key custom-bindings-map (kbd "C-c h o") #'helm-occur)
  (define-key custom-bindings-map (kbd "C-c h g") #'helm-google-suggest)
  (define-key custom-bindings-map (kbd "M-i")     #'helm-swoop)
  (define-key custom-bindings-map (kbd "M-I")     #'helm-multi-swoop-all)

  (define-key helm-map (kbd "<tab>") #'helm-execute-persistent-action)
  (define-key helm-map (kbd "C-i")   #'helm-execute-persistent-action)
  (define-key helm-map (kbd "C-z")   #'helm-select-action)
  #+END_SRC

** Bindings for built-ins

#+BEGIN_SRC emacs-lisp
 
;; Editing
(define-key custom-bindings-map (kbd "M-u")         'upcase-dwim)
(define-key custom-bindings-map (kbd "M-c")         'capitalize-dwim)
(define-key custom-bindings-map (kbd "M-l")         'downcase-dwim)
(define-key custom-bindings-map (kbd "M-]")         'other-frame)
(define-key custom-bindings-map (kbd "C-c s")       'ispell-word)

;; Org Mode
(define-key custom-bindings-map (kbd "C-c c")       'org-capture)
(define-key custom-bindings-map (kbd "C-c t")
  (lambda () (interactive) (org-agenda nil "n")))
(define-key custom-bindings-map (kbd "C-c l")       'org-store-link)
(define-key custom-bindings-map (kbd "C-c a")       'org-agenda)

;; Navigation
(define-key custom-bindings-map (kbd "M-s")         'avy-goto-word-1)
(define-key custom-bindings-map (kbd "C-c <up>")    'windmove-up)
(define-key custom-bindings-map (kbd "C-c <down>")  'windmove-down)
(define-key custom-bindings-map (kbd "C-c <left>")  'windmove-left)
(define-key custom-bindings-map (kbd "C-c <right>") 'windmove-right)
(define-key custom-bindings-map (kbd "C-x C-b")     'buffer-menu)
#+END_SRC

** Bindings for functions defined [[sec:defuns][above]].

#+BEGIN_SRC emacs-lisp
(define-key global-map          (kbd "M-p")     'jump-to-previous-like-this)
(define-key global-map          (kbd "M-n")     'jump-to-next-like-this)
(define-key custom-bindings-map (kbd "M-,")     'jump-to-previous-like-this)
(define-key custom-bindings-map (kbd "M-.")     'jump-to-next-like-this)
(define-key custom-bindings-map (kbd "C-x k")   'kill-this-buffer-unless-scratch)
(define-key custom-bindings-map (kbd "C-c C-0") 'global-scale-default)
(define-key custom-bindings-map (kbd "C-c C-=") 'global-scale-up)
(define-key custom-bindings-map (kbd "C-c C-+") 'global-scale-up)
(define-key custom-bindings-map (kbd "C-c C--") 'global-scale-down)
(define-key custom-bindings-map (kbd "C-c d")   'duplicate-thing)
(define-key custom-bindings-map (kbd "<C-tab>") 'tidy)
(define-key custom-bindings-map (kbd "M-§")     'toggle-shell)
(define-key custom-bindings-map (kbd "C-x |") 'toggle-window-split)
(dolist (n (number-sequence 1 9))
  (global-set-key (kbd (concat "M-" (int-to-string n)))
                  (lambda () (interactive) (switch-shell n))))
(define-key custom-bindings-map (kbd "C-c C-q")
  '(lambda ()
     (interactive)
     (focus-mode 1)
     (focus-read-only-mode 1)))
(with-eval-after-load 'org
  (define-key org-mode-map (kbd "C-'") 'org-sync-pdf))
#+END_SRC

Lastly we need to activate the map by creating and activating the
=minor-mode=.

#+BEGIN_SRC emacs-lisp
(define-minor-mode custom-bindings-mode
  "A mode that activates custom-bindings."
  t nil custom-bindings-map)
#+END_SRC
* License

  My Emacs configurations written in Org mode.

  Copyright (c) 2018 Jeff Dwyer 

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
